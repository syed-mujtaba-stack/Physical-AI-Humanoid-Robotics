"use strict";(globalThis.webpackChunktextbook_frontend=globalThis.webpackChunktextbook_frontend||[]).push([[6551],{8149:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"chapter-09-control","title":"Chapter 9: Control & Balance for Bipedal Robots","description":"Learning Objectives","source":"@site/docs/chapter-09-control.md","sourceDirName":".","slug":"/chapter-09-control","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapter-09-control","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chapter-09-control.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 8: Vision-Language-Action (VLA) Models","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapter-08-vla"},"next":{"title":"Chapter 10: Conversational Robotics with LLMs","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapter-10-conversational"}}');var t=r(4848),l=r(8453);const o={sidebar_position:10},s="Chapter 9: Control & Balance for Bipedal Robots",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"The Challenge of Bipedal Locomotion",id:"the-challenge-of-bipedal-locomotion",level:2},{value:"Why is Bipedal Walking Hard?",id:"why-is-bipedal-walking-hard",level:3},{value:"Human vs. Robot Walking",id:"human-vs-robot-walking",level:3},{value:"PID Control: The Foundation",id:"pid-control-the-foundation",level:2},{value:"PID Equation",id:"pid-equation",level:3},{value:"Implementing PID in Python",id:"implementing-pid-in-python",level:3},{value:"Tuning PID",id:"tuning-pid",level:3},{value:"PID for Joint Control",id:"pid-for-joint-control",level:3},{value:"Zero Moment Point (ZMP)",id:"zero-moment-point-zmp",level:2},{value:"Definition",id:"definition",level:3},{value:"Calculating ZMP",id:"calculating-zmp",level:3},{value:"ZMP-Based Walking",id:"zmp-based-walking",level:3},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:2},{value:"MPC for Walking",id:"mpc-for-walking",level:3},{value:"Whole-Body Control (WBC)",id:"whole-body-control-wbc",level:2},{value:"Task Hierarchy",id:"task-hierarchy",level:3},{value:"Quadratic Programming Formulation",id:"quadratic-programming-formulation",level:3},{value:"Lab Exercise: Implementing a Walking Controller",id:"lab-exercise-implementing-a-walking-controller",level:2},{value:"Objective",id:"objective",level:3},{value:"Step 1: Define Gait Pattern",id:"step-1-define-gait-pattern",level:3},{value:"Step 2: ZMP Trajectory",id:"step-2-zmp-trajectory",level:3},{value:"Step 3: MPC Controller",id:"step-3-mpc-controller",level:3},{value:"Step 4: Simulate in Gazebo",id:"step-4-simulate-in-gazebo",level:3},{value:"Quiz",id:"quiz",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-9-control--balance-for-bipedal-robots",children:"Chapter 9: Control & Balance for Bipedal Robots"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand bipedal locomotion challenges"}),"\n",(0,t.jsx)(n.li,{children:"Master PID control for joint-level control"}),"\n",(0,t.jsx)(n.li,{children:"Implement Model Predictive Control (MPC) for walking"}),"\n",(0,t.jsx)(n.li,{children:"Learn Whole-Body Control (WBC) for multi-task coordination"}),"\n",(0,t.jsx)(n.li,{children:"Implement Zero Moment Point (ZMP) based balance"}),"\n",(0,t.jsx)(n.li,{children:"Deploy walking controllers in simulation"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"the-challenge-of-bipedal-locomotion",children:"The Challenge of Bipedal Locomotion"}),"\n",(0,t.jsx)(n.p,{children:"Humans make walking look effortless, but it's one of the hardest problems in robotics."}),"\n",(0,t.jsx)(n.h3,{id:"why-is-bipedal-walking-hard",children:"Why is Bipedal Walking Hard?"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Challenge"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Underactuation"})}),(0,t.jsx)(n.td,{children:"Fewer actuators than degrees of freedom (can't control everything)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Instability"})}),(0,t.jsx)(n.td,{children:"Small support polygon (two feet)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Hybrid Dynamics"})}),(0,t.jsx)(n.td,{children:"Continuous (swing phase) + discrete (foot contact)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"High DOF"})}),(0,t.jsx)(n.td,{children:"12+ joints just for legs"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Energy Efficiency"})}),(0,t.jsx)(n.td,{children:"Batteries are limited"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"human-vs-robot-walking",children:"Human vs. Robot Walking"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Metric"}),(0,t.jsx)(n.th,{children:"Human"}),(0,t.jsx)(n.th,{children:"Typical Humanoid"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Energy Cost of Transport"})}),(0,t.jsx)(n.td,{children:"0.2"}),(0,t.jsx)(n.td,{children:"0.8-2.0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Walking Speed"})}),(0,t.jsx)(n.td,{children:"1.4 m/s"}),(0,t.jsx)(n.td,{children:"0.3-0.8 m/s"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Stability"})}),(0,t.jsx)(n.td,{children:"Excellent"}),(0,t.jsx)(n.td,{children:"Fragile"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Adaptability"})}),(0,t.jsx)(n.td,{children:"High (stairs, slopes)"}),(0,t.jsx)(n.td,{children:"Limited"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"pid-control-the-foundation",children:"PID Control: The Foundation"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"PID (Proportional-Integral-Derivative)"})," is the most common controller in robotics."]}),"\n",(0,t.jsx)(n.h3,{id:"pid-equation",children:"PID Equation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"u(t) = Kp * e(t) + Ki * \u222be(t)dt + Kd * de(t)/dt\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"e(t)"})," = error (desired - actual)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Kp"})," = proportional gain"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Ki"})," = integral gain"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Kd"})," = derivative gain"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementing-pid-in-python",children:"Implementing PID in Python"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class PIDController:\r\n    def __init__(self, kp, ki, kd, dt=0.01):\r\n        self.kp = kp\r\n        self.ki = ki\r\n        self.kd = kd\r\n        self.dt = dt\r\n        \r\n        self.integral = 0.0\r\n        self.prev_error = 0.0\r\n    \r\n    def compute(self, setpoint, measurement):\r\n        # Error\r\n        error = setpoint - measurement\r\n        \r\n        # Proportional term\r\n        p_term = self.kp * error\r\n        \r\n        # Integral term\r\n        self.integral += error * self.dt\r\n        i_term = self.ki * self.integral\r\n        \r\n        # Derivative term\r\n        derivative = (error - self.prev_error) / self.dt\r\n        d_term = self.kd * derivative\r\n        \r\n        # Update\r\n        self.prev_error = error\r\n        \r\n        # Control output\r\n        output = p_term + i_term + d_term\r\n        return output\n"})}),"\n",(0,t.jsx)(n.h3,{id:"tuning-pid",children:"Tuning PID"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Ziegler-Nichols Method"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Set ",(0,t.jsx)(n.code,{children:"Ki = 0"}),", ",(0,t.jsx)(n.code,{children:"Kd = 0"})]}),"\n",(0,t.jsxs)(n.li,{children:["Increase ",(0,t.jsx)(n.code,{children:"Kp"})," until system oscillates"]}),"\n",(0,t.jsxs)(n.li,{children:["Record ",(0,t.jsx)(n.code,{children:"Ku"})," (ultimate gain) and ",(0,t.jsx)(n.code,{children:"Tu"})," (oscillation period)"]}),"\n",(0,t.jsxs)(n.li,{children:["Set:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Kp = 0.6 * Ku"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Ki = 2 * Kp / Tu"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Kd = Kp * Tu / 8"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"pid-for-joint-control",children:"PID for Joint Control"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom std_msgs.msg import Float64\r\n\r\nclass JointPIDController(Node):\r\n    def __init__(self):\r\n        super().__init__('joint_pid_controller')\r\n        \r\n        # PID controller for knee joint\r\n        self.pid = PIDController(kp=50.0, ki=0.1, kd=5.0)\r\n        \r\n        # Subscribers and publishers\r\n        self.joint_sub = self.create_subscription(\r\n            JointState, '/joint_states', self.joint_callback, 10)\r\n        self.cmd_pub = self.create_publisher(\r\n            Float64, '/knee_effort_controller/command', 10)\r\n        \r\n        self.desired_angle = 0.5  # radians\r\n    \r\n    def joint_callback(self, msg):\r\n        # Find knee joint\r\n        try:\r\n            idx = msg.name.index('knee')\r\n            current_angle = msg.position[idx]\r\n            \r\n            # Compute control\r\n            effort = self.pid.compute(self.desired_angle, current_angle)\r\n            \r\n            # Publish\r\n            cmd = Float64()\r\n            cmd.data = effort\r\n            self.cmd_pub.publish(cmd)\r\n            \r\n        except ValueError:\r\n            pass\n"})}),"\n",(0,t.jsx)(n.h2,{id:"zero-moment-point-zmp",children:"Zero Moment Point (ZMP)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ZMP"})," is a stability criterion for bipedal walking."]}),"\n",(0,t.jsx)(n.h3,{id:"definition",children:"Definition"}),"\n",(0,t.jsx)(n.p,{children:"The ZMP is the point on the ground where the net moment from gravity and inertia is zero."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Stability Condition"}),": ZMP must stay inside the ",(0,t.jsx)(n.strong,{children:"support polygon"})," (convex hull of foot contacts)."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"If ZMP is inside support polygon \u2192 Stable\r\nIf ZMP is outside \u2192 Robot will tip over\n"})}),"\n",(0,t.jsx)(n.h3,{id:"calculating-zmp",children:"Calculating ZMP"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import numpy as np\r\n\r\ndef calculate_zmp(com_position, com_acceleration, total_mass, g=9.81):\r\n    """\r\n    Calculate ZMP x-coordinate\r\n    \r\n    Args:\r\n        com_position: [x, y, z] center of mass position\r\n        com_acceleration: [ax, ay, az] COM acceleration\r\n        total_mass: robot mass (kg)\r\n        g: gravity (m/s^2)\r\n    \r\n    Returns:\r\n        zmp_x: ZMP x-coordinate\r\n    """\r\n    zmp_x = com_position[0] - (com_position[2] / (com_acceleration[2] + g)) * com_acceleration[0]\r\n    return zmp_x\n'})}),"\n",(0,t.jsx)(n.h3,{id:"zmp-based-walking",children:"ZMP-Based Walking"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Linear Inverted Pendulum Model (LIPM)"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class LIPMWalking:\r\n    def __init__(self, com_height=0.8, step_time=0.8):\r\n        self.h = com_height  # COM height\r\n        self.T = step_time   # Step duration\r\n        self.g = 9.81\r\n        \r\n        # Natural frequency\r\n        self.omega = np.sqrt(self.g / self.h)\r\n    \r\n    def compute_com_trajectory(self, zmp_ref):\r\n        """\r\n        Compute COM trajectory to track ZMP reference\r\n        """\r\n        # Simplified: COM position to achieve desired ZMP\r\n        com_x = zmp_ref + self.h / self.g * 0  # Simplified (full version uses differential equations)\r\n        return com_x\n'})}),"\n",(0,t.jsx)(n.h2,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"MPC"})," optimizes future control actions over a time horizon."]}),"\n",(0,t.jsx)(n.h3,{id:"mpc-for-walking",children:"MPC for Walking"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import cvxpy as cp\r\n\r\nclass MPCWalkingController:\r\n    def __init__(self, horizon=10, dt=0.1):\r\n        self.N = horizon  # Prediction horizon\r\n        self.dt = dt\r\n    \r\n    def solve(self, current_state, zmp_reference):\r\n        """\r\n        Solve MPC optimization problem\r\n        \r\n        Args:\r\n            current_state: [com_x, com_vx]\r\n            zmp_reference: desired ZMP trajectory (N steps)\r\n        \r\n        Returns:\r\n            optimal_control: COM acceleration commands\r\n        """\r\n        # State: [position, velocity]\r\n        x = cp.Variable((2, self.N + 1))\r\n        u = cp.Variable(self.N)  # Control (COM acceleration)\r\n        \r\n        # Dynamics: x[k+1] = A*x[k] + B*u[k]\r\n        A = np.array([[1, self.dt], [0, 1]])\r\n        B = np.array([[0.5 * self.dt**2], [self.dt]])\r\n        \r\n        # Cost function\r\n        cost = 0\r\n        constraints = [x[:, 0] == current_state]\r\n        \r\n        for k in range(self.N):\r\n            # Track ZMP reference\r\n            zmp_k = x[0, k] - (0.8 / 9.81) * u[k]  # Simplified ZMP equation\r\n            cost += cp.square(zmp_k - zmp_reference[k])\r\n            \r\n            # Dynamics constraint\r\n            constraints += [x[:, k+1] == A @ x[:, k] + B.flatten() * u[k]]\r\n            \r\n            # Control limits\r\n            constraints += [cp.abs(u[k]) <= 2.0]  # Max acceleration\r\n        \r\n        # Solve\r\n        problem = cp.Problem(cp.Minimize(cost), constraints)\r\n        problem.solve()\r\n        \r\n        return u.value\n'})}),"\n",(0,t.jsx)(n.h2,{id:"whole-body-control-wbc",children:"Whole-Body Control (WBC)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"WBC"})," coordinates all joints to achieve multiple tasks simultaneously."]}),"\n",(0,t.jsx)(n.h3,{id:"task-hierarchy",children:"Task Hierarchy"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"High Priority"}),": Balance (ZMP, COM)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Medium Priority"}),": Foot placement"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Low Priority"}),": Arm swing, head orientation"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"quadratic-programming-formulation",children:"Quadratic Programming Formulation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import qpsolvers\r\n\r\nclass WholeBodyController:\r\n    def __init__(self, num_joints=12):\r\n        self.n = num_joints\r\n    \r\n    def solve(self, tasks, constraints):\r\n        """\r\n        Solve WBC as QP:\r\n        \r\n        minimize: ||J*q_ddot - task_acc||^2\r\n        subject to: dynamics and joint limits\r\n        \r\n        Args:\r\n            tasks: list of (Jacobian, desired_acceleration, weight)\r\n            constraints: joint limits, contact forces\r\n        \r\n        Returns:\r\n            q_ddot: joint accelerations\r\n        """\r\n        # Build QP matrices\r\n        H = np.eye(self.n)  # Quadratic cost\r\n        f = np.zeros(self.n)  # Linear cost\r\n        \r\n        for J, task_acc, weight in tasks:\r\n            H += weight * (J.T @ J)\r\n            f -= weight * (J.T @ task_acc)\r\n        \r\n        # Solve QP\r\n        q_ddot = qpsolvers.solve_qp(H, f, G=None, h=None)\r\n        return q_ddot\n'})}),"\n",(0,t.jsx)(n.h2,{id:"lab-exercise-implementing-a-walking-controller",children:"Lab Exercise: Implementing a Walking Controller"}),"\n",(0,t.jsx)(n.h3,{id:"objective",children:"Objective"}),"\n",(0,t.jsx)(n.p,{children:"Implement a simple ZMP-based walking controller for a simulated humanoid."}),"\n",(0,t.jsx)(n.h3,{id:"step-1-define-gait-pattern",children:"Step 1: Define Gait Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class GaitGenerator:\r\n    def __init__(self):\r\n        self.step_length = 0.2  # meters\r\n        self.step_height = 0.05  # meters\r\n        self.step_time = 0.8    # seconds\r\n    \r\n    def generate_footsteps(self, num_steps=4):\r\n        footsteps = []\r\n        for i in range(num_steps):\r\n            x = i * self.step_length\r\n            y = 0.1 if i % 2 == 0 else -0.1  # Alternate feet\r\n            footsteps.append((x, y))\r\n        return footsteps\n"})}),"\n",(0,t.jsx)(n.h3,{id:"step-2-zmp-trajectory",children:"Step 2: ZMP Trajectory"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def generate_zmp_trajectory(footsteps, dt=0.01):\r\n    zmp_traj = []\r\n    for i in range(len(footsteps) - 1):\r\n        # ZMP stays at support foot during swing\r\n        start = footsteps[i]\r\n        end = footsteps[i + 1]\r\n        \r\n        # Linear interpolation\r\n        steps = int(0.8 / dt)  # 0.8 seconds per step\r\n        for t in range(steps):\r\n            alpha = t / steps\r\n            zmp_x = start[0] + alpha * (end[0] - start[0])\r\n            zmp_traj.append(zmp_x)\r\n    \r\n    return zmp_traj\n"})}),"\n",(0,t.jsx)(n.h3,{id:"step-3-mpc-controller",children:"Step 3: MPC Controller"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'controller = MPCWalkingController(horizon=10, dt=0.1)\r\n\r\ncurrent_state = np.array([0.0, 0.0])  # [position, velocity]\r\nzmp_ref = generate_zmp_trajectory(footsteps)\r\n\r\nfor k in range(len(zmp_ref) - 10):\r\n    # Solve MPC\r\n    u_opt = controller.solve(current_state, zmp_ref[k:k+10])\r\n    \r\n    # Apply first control action\r\n    com_acc = u_opt[0]\r\n    \r\n    # Update state (simplified dynamics)\r\n    current_state[1] += com_acc * 0.1  # velocity\r\n    current_state[0] += current_state[1] * 0.1  # position\r\n    \r\n    print(f"Step {k}: COM position = {current_state[0]:.3f}, ZMP ref = {zmp_ref[k]:.3f}")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"step-4-simulate-in-gazebo",children:"Step 4: Simulate in Gazebo"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"ros2 launch humanoid_walking walking_controller.launch.py\n"})}),"\n",(0,t.jsx)(n.h2,{id:"quiz",children:"Quiz"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"What does PID stand for?"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A) Proportional-Integral-Differential"}),"\n",(0,t.jsx)(n.li,{children:"B) Proportional-Integral-Derivative"}),"\n",(0,t.jsx)(n.li,{children:"C) Position-Inertia-Damping"}),"\n",(0,t.jsx)(n.li,{children:"D) Power-Input-Device"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Answer: B"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"What is the ZMP stability condition?"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A) ZMP must be at the center of mass"}),"\n",(0,t.jsx)(n.li,{children:"B) ZMP must be inside the support polygon"}),"\n",(0,t.jsx)(n.li,{children:"C) ZMP must be zero"}),"\n",(0,t.jsx)(n.li,{children:"D) ZMP must be at the foot"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Answer: B"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"What is the advantage of MPC over PID?"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A) Simpler to implement"}),"\n",(0,t.jsx)(n.li,{children:"B) Optimizes over future time horizon"}),"\n",(0,t.jsx)(n.li,{children:"C) Requires less computation"}),"\n",(0,t.jsx)(n.li,{children:"D) Works without sensors"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Answer: B"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"What is Whole-Body Control used for?"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A) Controlling a single joint"}),"\n",(0,t.jsx)(n.li,{children:"B) Coordinating all joints for multiple tasks"}),"\n",(0,t.jsx)(n.li,{children:"C) Only for arm control"}),"\n",(0,t.jsx)(n.li,{children:"D) Measuring robot weight"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Answer: B"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"In this chapter, we mastered control theory for bipedal humanoid robots. We learned PID control for joint-level control, ZMP for balance analysis, MPC for optimal walking, and Whole-Body Control for multi-task coordination. We implemented a simple walking controller using ZMP and MPC. Control is the bridge between planning and execution, enabling humanoids to move gracefully and safely."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Next Chapter"}),": We'll integrate conversational AI with humanoid robots using speech recognition and language models."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>s});var i=r(6540);const t={},l=i.createContext(t);function o(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);